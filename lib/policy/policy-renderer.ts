/**
 * Policy Document Renderer
 * Generate DOCX documents with tracked changes
 * @version 1.0.0
 */

import { Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType } from 'docx'
import { PolicyRenderOptions, SelectedClause, RedlineChange, GeneratedPolicy } from './types'
import { POLICY_TEMPLATES } from './templates'
import ClauseSelector from './clause-selector'

export class PolicyRenderer {
  private clauseSelector: ClauseSelector

  constructor() {
    this.clauseSelector = new ClauseSelector()
  }

  /**
   * Render policy document as DOCX buffer
   */
  async renderPolicyDocx(options: PolicyRenderOptions): Promise<Buffer> {
    console.log('Rendering policy DOCX with options:', options)

    // Get template
    const template = POLICY_TEMPLATES.find(t => t.id === options.templateId)
    if (!template) {
      throw new Error(`Template not found: ${options.templateId}`)
    }

    // Get selected clauses
    const clauses = options.selectedClauses.map(clauseId => {
      const clause = this.clauseSelector.getClauseById(clauseId)
      if (!clause) {
        throw new Error(`Clause not found: ${clauseId}`)
      }
      return clause
    })

    // Create document
    const doc = new Document({
      creator: 'AI Readiness Policy Engine',
      title: template.name,
      description: template.description,
      sections: [{
        properties: {},
        children: [
          // Header
          new Paragraph({
            children: [
              new TextRun({
                text: template.name,
                bold: true,
                size: 32, // 16pt
              }),
            ],
            heading: HeadingLevel.TITLE,
            alignment: AlignmentType.CENTER,
            spacing: { after: 400 },
          }),

          // Metadata paragraph
          new Paragraph({
            children: [
              new TextRun({
                text: `Version: ${template.version} | Generated: ${new Date().toLocaleDateString()}`,
                italics: true,
                size: 20, // 10pt
              }),
            ],
            alignment: AlignmentType.CENTER,
            spacing: { after: 600 },
          }),

          // Organization placeholder
          new Paragraph({
            children: [
              new TextRun({
                text: 'Organization: [ORGANIZATION_NAME]',
                bold: true,
                size: 24, // 12pt
              }),
            ],
            spacing: { after: 400 },
          }),

          // Effective date
          new Paragraph({
            children: [
              new TextRun({
                text: `Effective Date: ${options.headerFooter?.effectiveDate || '[EFFECTIVE_DATE]'}`,
                size: 22, // 11pt
              }),
            ],
            spacing: { after: 600 },
          }),

          // Table of Contents placeholder
          new Paragraph({
            children: [
              new TextRun({
                text: 'Table of Contents',
                bold: true,
                size: 28, // 14pt
              }),
            ],
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 400, after: 200 },
          }),

          new Paragraph({
            children: [
              new TextRun({
                text: '[Table of Contents will be generated here]',
                italics: true,
                size: 22,
              }),
            ],
            spacing: { after: 600 },
          }),

          // Policy sections
          ...this.generatePolicySections(clauses, options),

          // Footer information
          new Paragraph({
            children: [
              new TextRun({
                text: 'Document Information',
                bold: true,
                size: 28,
              }),
            ],
            heading: HeadingLevel.HEADING_1,
            spacing: { before: 800, after: 200 },
          }),

          new Paragraph({
            children: [
              new TextRun({
                text: `Generated by: AI Readiness Policy Engine\n`,
                size: 22,
              }),
              new TextRun({
                text: `Template: ${template.name}\n`,
                size: 22,
              }),
              new TextRun({
                text: `Audience: ${template.audience.toUpperCase()}\n`,
                size: 22,
              }),
              new TextRun({
                text: `Jurisdiction: ${template.jurisdiction}\n`,
                size: 22,
              }),
              new TextRun({
                text: `Generated: ${new Date().toISOString()}\n`,
                size: 22,
              }),
            ],
            spacing: { after: 400 },
          }),

          // Legal disclaimer
          new Paragraph({
            children: [
              new TextRun({
                text: 'Legal Disclaimer',
                bold: true,
                size: 24,
              }),
            ],
            spacing: { before: 400, after: 200 },
          }),

          new Paragraph({
            children: [
              new TextRun({
                text: 'This policy template is provided for informational purposes only and does not constitute legal advice. Organizations should consult with qualified legal counsel to ensure compliance with applicable laws and regulations.',
                italics: true,
                size: 20,
              }),
            ],
            spacing: { after: 200 },
          }),
        ],
      }],
    })

    // Generate buffer
    const buffer = await Packer.toBuffer(doc)
    return buffer
  }

  /**
   * Generate policy sections from clauses
   */
  private generatePolicySections(clauses: any[], options: PolicyRenderOptions): Paragraph[] {
    const sections: Paragraph[] = []
    let sectionNumber = 1

    for (const clause of clauses) {
      // Section heading
      sections.push(
        new Paragraph({
          children: [
            new TextRun({
              text: `${sectionNumber}. ${clause.title}`,
              bold: true,
              size: 26, // 13pt
            }),
          ],
          heading: HeadingLevel.HEADING_1,
          spacing: { before: 600, after: 200 },
        })
      )

      // Section content
      const bodyParagraphs = this.formatClauseBody(clause.body, options.trackedChanges)
      sections.push(...bodyParagraphs)

      // Add metadata if enabled
      if (process.env.NODE_ENV === 'development') {
        sections.push(
          new Paragraph({
            children: [
              new TextRun({
                text: `[Clause ID: ${clause.id} | Risk Level: ${clause.riskLevel} | Tags: ${clause.tags.join(', ')}]`,
                italics: true,
                size: 18,
                color: '666666',
              }),
            ],
            spacing: { after: 400 },
          })
        )
      }

      sectionNumber++
    }

    return sections
  }

  /**
   * Format clause body with paragraph breaks and tracked changes
   */
  private formatClauseBody(body: string, trackedChanges: boolean = false): Paragraph[] {
    const paragraphs: Paragraph[] = []
    
    // Split body into paragraphs
    const parts = body.split('\n\n').filter(part => part.trim())
    
    for (const part of parts) {
      // Replace placeholders
      const processedText = part
        .replace(/\[ORGANIZATION_NAME\]/g, '[Organization Name]')
        .replace(/\[EFFECTIVE_DATE\]/g, '[Effective Date]')
        .replace(/\[STATE\]/g, '[State/Province]')

      // Create paragraph with proper formatting
      const textRun = new TextRun({
        text: processedText,
        size: 22, // 11pt
      })

      paragraphs.push(
        new Paragraph({
          children: [textRun],
          spacing: { after: 200 },
          alignment: AlignmentType.JUSTIFIED,
        })
      )
    }

    return paragraphs
  }

  /**
   * Add tracked changes to document
   */
  private addTrackedChanges(
    paragraph: Paragraph, 
    changes: RedlineChange[]
  ): Paragraph {
    // Implementation would add revision marks
    // For now, return original paragraph
    return paragraph
  }

  /**
   * Generate a complete policy document with metadata
   */
  async generatePolicy(
    templateId: string,
    selectedClauses: string[],
    metadata: {
      userId: string
      organizationId: string
      organizationName?: string
    }
  ): Promise<GeneratedPolicy> {
    const template = POLICY_TEMPLATES.find(t => t.id === templateId)
    if (!template) {
      throw new Error(`Template not found: ${templateId}`)
    }

    const clauses = selectedClauses.map(clauseId => {
      const clause = this.clauseSelector.getClauseById(clauseId)
      if (!clause) {
        throw new Error(`Clause not found: ${clauseId}`)
      }
      return {
        ...clause,
        selected: true,
        reason: 'Manually selected',
        priority: 1
      }
    })

    // Calculate document stats
    const content = clauses.map(c => c.body).join('\n\n')
    const wordCount = content.split(/\s+/).length
    const pageCount = Math.ceil(wordCount / 250) // Approximate pages

    return {
      id: `policy_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      templateId,
      selectedClauses: clauses,
      document: {
        title: template.name,
        content,
        wordCount,
        pageCount
      },
      trackedChanges: [],
      metadata: {
        generatedAt: new Date().toISOString(),
        userId: metadata.userId,
        organizationId: metadata.organizationId,
        parameters: {
          audience: template.audience,
          riskProfile: 'medium',
          toolUseMode: 'permitted'
        }
      }
    }
  }

  /**
   * Render policy as HTML for preview
   */
  async renderPolicyHtml(
    templateId: string,
    selectedClauses: string[],
    organizationName?: string
  ): Promise<string> {
    const template = POLICY_TEMPLATES.find(t => t.id === templateId)
    if (!template) {
      throw new Error(`Template not found: ${templateId}`)
    }

    const clauses = selectedClauses.map(clauseId => {
      const clause = this.clauseSelector.getClauseById(clauseId)
      if (!clause) {
        throw new Error(`Clause not found: ${clauseId}`)
      }
      return clause
    })

    const html = `
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>${template.name}</title>
    <style>
        body { font-family: 'Times New Roman', serif; line-height: 1.6; margin: 2in; color: #333; }
        h1 { text-align: center; margin-bottom: 1in; font-size: 24px; }
        h2 { color: #2c5aa0; margin-top: 2em; margin-bottom: 0.5em; font-size: 18px; }
        p { margin-bottom: 1em; text-align: justify; }
        .metadata { text-align: center; font-style: italic; margin-bottom: 2em; }
        .org-name { font-weight: bold; margin-bottom: 1em; }
        .footer { margin-top: 3em; padding-top: 1em; border-top: 1px solid #ccc; font-size: 12px; color: #666; }
        .clause-meta { font-size: 11px; color: #888; font-style: italic; margin-bottom: 1em; }
    </style>
</head>
<body>
    <h1>${template.name}</h1>
    
    <div class="metadata">
        Version: ${template.version} | Generated: ${new Date().toLocaleDateString()}
    </div>
    
    <div class="org-name">
        Organization: ${organizationName || '[Organization Name]'}
    </div>
    
    <p><strong>Effective Date:</strong> [Effective Date]</p>
    
    ${clauses.map((clause, index) => `
        <h2>${index + 1}. ${clause.title}</h2>
        ${clause.body.split('\n\n').map(para => `<p>${para.replace(/\[ORGANIZATION_NAME\]/g, organizationName || '[Organization Name]')}</p>`).join('')}
        ${process.env.NODE_ENV === 'development' ? `
        <div class="clause-meta">
            [Clause ID: ${clause.id} | Risk Level: ${clause.riskLevel} | Tags: ${clause.tags.join(', ')}]
        </div>
        ` : ''}
    `).join('')}
    
    <div class="footer">
        <p><strong>Document Information</strong></p>
        <p>Generated by: AI Readiness Policy Engine<br>
        Template: ${template.name}<br>
        Audience: ${template.audience.toUpperCase()}<br>
        Jurisdiction: ${template.jurisdiction}<br>
        Generated: ${new Date().toISOString()}</p>
        
        <p><strong>Legal Disclaimer:</strong><br>
        This policy template is provided for informational purposes only and does not constitute legal advice. 
        Organizations should consult with qualified legal counsel to ensure compliance with applicable laws and regulations.</p>
    </div>
</body>
</html>
    `

    return html
  }
}

export default PolicyRenderer
